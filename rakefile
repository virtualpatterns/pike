require 'rubygems'
require 'bundler/setup'

require 'chronic'
require 'fileutils'
require 'logrotate'
require 'rake'

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), %w[lib]))

require 'pike/application'
require 'pike/models'
require 'pike/version'

namespace :mongo do

  desc 'Run MongoDB'
  task :run do |task|
    system("bundle exec mongod run --rest --quiet --config #{File.join(File.dirname(__FILE__), %w[mongod.conf])}")
  end

end

namespace :pike do

  desc 'Create console'
  task :console do |task|
    system("clear && bundle exec ruby_app console")
  end

  desc 'Run'
  task :run do |task|
    system("clear && bundle exec ruby_app run")
  end

  desc 'Run w/ coverage report'
  task :coverage do |task|
    system("clear && rm -rf coverage && bundle exec rcov --include $PATH --exclude bin,gems ruby_app -- run && open coverage/index.html")
  end

  desc 'Dump database'
  task :dump do |task|
    system("rm -rf dump && bundle exec mongodump --db pike --out dump && tar -czf dump.tgz dump && rm -rf dump")
  end

  desc 'Restore a dumped database'
  task :restore do |task|
    system("rm -rf dump && tar -xzf dump.tgz && bundle exec mongorestore --db pike --drop dump/pike &&  rm -rf dump")
  end

  desc 'Drop database'
  task :drop do |task|
    Pike::Application.create_default!
    Pike::Application.drop_database!
  end

  desc 'Rotate log'
  task :rotate do |task|
    puts LogRotate.rotate_file(File.join(Pike::ROOT, %w[log application.log]), :date_time_ext => true, :date_time_format => '%Y%m%d')
  end

  desc 'Get version'
  task :version do |task|
    puts Pike::VERSION
  end

  desc 'Push to development, update version, and commit'
  task :push, :next_version do |task, arguments|
    if arguments.next_version
      version_file = File.join(Pike::ROOT, %w[lib pike version.rb])
      system "git checkout development && git push origin development && sed 's|[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*|#{arguments.next_version}|g' < '#{version_file}' > '#{version_file}.out' && rm '#{version_file}' && mv '#{version_file}.out' '#{version_file}' && git commit --all --message='Incrementing version'"
    end
  end

  desc 'Merge development and staging, push staging'
  task :merge, :version do |task, arguments|
    system "git checkout staging && git pull origin staging && git merge origin/development && git push origin staging && git checkout development"
  end

  namespace :identities do

    desc 'Print all identities'
    task :print_all do |task|
      Pike::Application.create_default!
      Pike::Identity.all.each do |identity|
        puts "identity.user.url=#{identity.user.url.inspect}, identity.created_at=#{identity.created_at}, identity.expires=#{identity.expires}"
      end
    end

    desc 'Expire all identities'
    task :expire_all do |task|
      Pike::Application.create_default!
      Pike::Identity.all.each do |identity|
        identity.expires = Chronic.parse('yesterday')
        identity.save!
      end
    end

  end

  namespace :test do

    desc 'Run feature tests for the given feature file or all features files if no argument is provided'
    task :features, :file do |task, arguments|
      if arguments.file
        system("bundle exec cucumber --format pretty --tags ~@broken --require features '#{arguments.file}'")
      else
        system("bundle exec cucumber --format pretty --tags ~@broken --require features")
      end
    end

    desc 'Run RSpec tests'
    task :specs, :file, :line do |task, arguments|
      if arguments.file
        if arguments.line
          system("bundle exec rspec #{arguments.file} --line_number=#{arguments.line} --format=documentation --colour")
        else
          system("bundle exec rspec #{arguments.file} --format=documentation --colour")
        end
      else
        system("bundle exec rspec spec/ --format=documentation --colour")
      end
    end

    desc 'Run all tests'
    task :all => ['test:specs',
                  'test:features']

  end

end

